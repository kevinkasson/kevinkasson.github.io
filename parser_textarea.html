<html>
<head>
<title>Javascript Parser</title>
<script src="esprima.js"></script>
</head>
<body>
<script type="text/javascript">
Parser = function() {

  var parseTimer = null; //Controls the timer that parses the code...it parses 1000ms after the user stops typing.
  var e = document.body.appendChild(document .createElement("textarea")); //Create the input textarea,
  var o = document.body.appendChild(document.createElement("div")); //and the parser output div.
  e.cols="40"; //Set the size of the textarea
  e.rows="16";
  e.addEventListener("input",function() { clearTimeout(parseTimer); parseTimer = setTimeout(doParse.bind(this),1000); }.bind(this)); //And add the event handler.
  var w = new Object();  //This object controls the whitelist/blacklist,
  var p = new Array(); //and this one controls the structuring requirements.

  function setRequirements(ww) { //This is the public function to set the whitelist/blacklist.
    return w = ww;
  }

  function setStructures(pp) { //This is the public function to set the structuring requirements.
    return p = pp;
  }
  
  function setValue(v) {
    return myCodeMirror.setValue(v);
  }
  function getValue() {
    return myCodeMirror.getValue();
  }

  function doParse() {  //This function parses the textarea.
    try {
      var parsed = esprima.parse(e.value); //Esprima sometimes throws errors if the input code is malformed, so we'll use a try/catch block.
    }
    catch (err) {
      return o.innerHTML = "Syntax error" + ((typeof(err.lineNumber) !== undefined) ? " on line " + err.lineNumber + ": " + err.description : "."); //If there was an error, let the user know where.  It would be best practice here to test for all types of Esprima errors, and do something different if it's an actual JavaScript error instead of an Esprima-thrown syntax error.
    }
    var pa = new Array(); //This array stores the paths generated by the traversal function.
    for (var i in w) { //The same object stores the whitelist/blacklist requirements as well as the results.  We'll loop through it and reset all the results.
      w[i].found = 0;
    }
    var r = traverseAST(parsed,w,pa); //Traverse the syntax tree.
    var pp = p.slice(0); //Generate a copy of the path requirements.
    var output = ""; //This variable stores the output text before it's displayed.
    for (var i in r) { //The traversal function generated the whitelist/blacklist results, so we'll handle those now.
      if (r[i].required && (r[i].found < r[i].required)) {  //If we found less than required, we'll output an error.
        output += i + " failed: " + w[i].required + " required, found " + w[i].found + ".<br />";
      }
      else if (r[i].limit && (r[i].found > r[i].limit)) { //Likewise if we found more than the limit, we'll output an error.
        output += i + " failed: " + w[i].required + " maximum, found " + w[i].found + ".<br />";
      }
      else { //Otherwise we're within the correct range and we'll output success.
        output += i + " success!<br />";
      }
    }
    for (var i in pa) { //Now we'll handle the structuring requirements.  We use the generated paths array as the outer loop because there will be many more code paths than path requirements.  If we did this as the inner loop, we'd loop over the same elements more times.
      for (j=0;j<pp.length;j++) { //Loop through each required path...
        if (new RegExp(pp[j]).test(pa[i])) { //and if it's found, we output success and remove it from the array.  If we didn't remove it, we'd find the same required path many times.  This might be useful in a different scenario.
        //if (pa[i].indexOf(pp[j]) > -1) { //To not allow regex, we would use this line instead of the above.
          output+= pp[j] + " structure found!<br />"; //Output success,
          pp.splice(j,1);  //and remove it from the array.
          j-=1;
        }
      }
    }
    for (var i in pp) { //Anything left in the array was not found, so we'll output failure.
      output+= pp[i] + " structure not found!<br />"; //Output failure.
    } //This has the disadvantage of outputting all the successes first and failures afterwards, but it saves some loop iterations since it removes the ones that have been found from the array.
    //We could store a found property like in the whitelist/blacklist object, but then we'd waste some loop iterations.
    //We could also create another object to match the outputs to the input array to keep them in the same order, but this seems unnecessary.
    o.innerHTML = output; //Put the output in the div,
    return parsed; //and end the function.
  }

  function traverseAST(node, w, pa, path) { //This is a recursive function to traverse the syntax tree.
    //Argument 0 is the AST to be traversed,
    //Argument 1 is a reference to the whitelist/blacklist object,
    //Argument 2 is a reference to the paths array,
    //Argument 3 is used to keep track of the current path.

    var t = null; //This variable is used to check if we're at the end of a tree branch.
    if (typeof(path) == "undefined") { path="Root"; } //If the path isn't set, i.e. we're calling the function directly, then set the path to Root.
    //This makes it possible to specify a structure that is /not/ within another structure, i.e. Root->ForStatement will match only a non-nested For loop.
    for (var key in node) { //Loop through each property in the node,
      if (node.hasOwnProperty(key)) { //And check if it's a built-in property or not.
        var child = node[key];
        if ((typeof child === "object") && (child !== null)) { //If the node is not an object, it's not a property we're concerned with here.
          if (Array.isArray(child)) { //If it's an array, handle each element.
            child.forEach(function(node) {
              if (node == undefined) { return false; }
              if (node.type in w) { //If it's in the whitelist/blacklist, add one to the found count.  We check if it's in the list because otherwise we don't care about it.
                w[node.type].found+=1;
              }
              var p = path;
              if (node.type != "BlockStatement") { //I'm ignoring BlackStatements in the code path in order to make it easier to specify structuring requirements.
                p += "->" + node.type;
                if (path.length < 1) { p = p.substring(2); } //This is only needed if the start of the path is set to "" rather than "Root".
              }
              t = traverseAST(node, w, pa, p);
            });
          }
          else {
            if (child == undefined) { return false; }
            if (child.type in w) {
              w[child.type].found+=1;
            }
            var p = path;
            if (child.type != "BlockStatement") {
              p += "->" + child.type;
              if (path.length < 1) { p = p.substring(2); }
            }
            t = traverseAST(child, w, pa, p);
          }
        }
      }
    }
    if (t == null) { //If we didn't recurse, we're at the end of the path.
      pa.push(path); //In that case, we'll push the path we've generated to the array.
    }
    return w; //We'll return the whitelist/blacklist object for convenience.
  }

  setTimeout(doParse, 100);

  return {setRequirements: setRequirements, setStructures: setStructures, TextArea: e};

}



myParser = new Parser();
myParser.setRequirements({FunctionDeclaration: { required: 2 }, WhileStatement: { required: 1, limit: 3 } });
myParser.setStructures(["ForStatement->.*SwitchStatement","FunctionDeclaration->FunctionDeclaration->IfStatement","SwitchStatement"]);

if (window.location.search == "?success") {
  myParser.TextArea.value = "if (a) {\n  if (b) {\n    for (i=0;i<5;i++) {\n      switch(d) {\n        case 0:\n          f.push(true);\n          break;\n        default:\n          f.push(false);\n          break;\n      }\n    }\n  }\n  alert('test');\n  for (i=0;i<5;i++) {\n  }\n}\nfunction abc(a) {\n  function bcd(e) {\n    if (e) return false;\n    return true;\n  }\n  if (a == c) {\n    return b.push(a);\n  }\n  return c;\n}\nwhile (a) {\n  alert('test');\n}";
}
else {
  myParser.TextArea.value = "if (a) {\n  if (b) {\n    for (i=0;i<5;i++) {\n    }\n  }\n  alert('test');\n  for (i=0;i<5;i++) {\n  }\n}\nfunction test(a) {\n  if (a == c) {\n    return b.push(a);\n  }\n  return c;\n}\nwhile (a) {\n  alert('test');\n}";
}


</script>
</body>
</html>